SQL Assignment:
------------------------------------------------------------------------------------------------------------------------------------------------------
SET_1:
------------------------------------------------------------------------------------------------------------------------------------------------------
Q1. 
SELECT *
FROM City
WHERE COUNTRYCODE LIKE '%USA%'
AND POPULATION > 100000;

Q2. 
SELECT NAME
FROM City
WHERE COUNTRYCODE LIKE '%USA%'
AND POPULATION > 120000;

Q3. 
select * from City;

Q4. 
SELECT *
FROM City
WHERE ID = 1661;

Q5. 
SELECT *
FROM City
WHERE COUNTRYCODE LIKE '%JPN%';

Q6. 
SELECT NAME
FROM City
WHERE COUNTRYCODE LIKE '%JPN%';

Q7. 
SELECT CITY,STATE 
FROM STATION;

Q8.
SELECT DISTINCT(CITY) AS City_Name 
FROM STATION 
WHERE ID%2 = 0 
ORDER BY CITY ASC;

Q9.
SELECT 
COUNT(CITY) AS TOTAL_NUMBER_OF_RECORDS,
COUNT(DISTINCT(CITY)) AS NUMBER_OF_UNIQUE_CITY_NAMES,
(COUNT(CITY) - COUNT(DISTINCT(CITY))) AS DIFFERENCE_CITY_COUNT  
FROM STATION;

Q10.
SELECT CITY,LENGTH(CITY)AS MIN_LENGTH_OF_CITY 
FROM STATION 
ORDER BY LENGTH(CITY),CITY 
LIMIT 1;

SELECT CITY,LENGTH(CITY) AS MAX_LENGTH_OF_CITY 
FROM STATION 
ORDER BY LENGTH(CITY) DESC,CITY 
LIMIT 1;

Q11.
SELECT DISTINCT(CITY) AS DISTINCT_CITY_NAME 
FROM STATION 
WHERE lower(SUBSTR(city,1,1)) in ('a','e','i','o','u');

Q12.
SELECT DISTINCT CITY 
FROM STATION
WHERE lcase(CITY) LIKE '%a'
OR lcase(CITY) LIKE '%e'
OR lcase(CITY) LIKE '%i'
OR lcase(CITY) LIKE '%o'
OR lcase(CITY) LIKE '%u'
ORDER BY CITY;

Q13.
SELECT DISTINCT CITY 
FROM STATION
WHERE lcase(CITY) NOT LIKE 'a%'
AND lcase(CITY) NOT LIKE 'e%'
AND lcase(CITY) NOT LIKE 'i%'
AND lcase(CITY) NOT LIKE 'o%'
AND lcase(CITY) NOT LIKE 'u%'
ORDER BY CITY;

Q14.
SELECT DISTINCT CITY 
FROM STATION
WHERE lcase(CITY) NOT LIKE '%a'
AND lcase(CITY) NOT LIKE '%e'
AND lcase(CITY) NOT LIKE '%i'
AND lcase(CITY) NOT LIKE '%o'
AND lcase(CITY) NOT LIKE '%u'
ORDER BY CITY;

Q15. and Q16.
select distinct CITY 
from STATION 
where CITY not regexp '^[aeiou]' 
or city not regexp '[aeiou]$';

Q17.
SELECT 
product_id, 
product_name 
FROM Product 
WHERE product_id NOT IN (SELECT product_id 
                         FROM   Sales 
                         WHERE  sale_date NOT BETWEEN '2019-01-01' 
						 AND '2019-03-31'); 

Q18.
select distinct author_id as id 
from Views 
where author_id = viewer_id 
order by author_id asc;

Q19.
select round(100*d2.immediate_orders/count(d1.delivery_id), 2) as immediate_percentage
from Delivery d1,
    (select count(order_date) as immediate_orders
    from Delivery 
    where (order_date = customer_pref_delivery_date)) d2;

Q20.
SELECT 
ad_id,
ROUND(100 * COALESCE(SUM(action = 'Clicked') / SUM(action IN ('Clicked', 'Viewed')), 0), 2) ctr
FROM Ads
GROUP BY ad_id
ORDER BY ctr DESC, ad_id;

Q21.
select 
employee_id, 
count(*) over(partition by team_id) as team_size
from Employee order by team_size desc;

Q22.
select 
c.country_name,
case 
    when AVG(w.weather_state*1.0) <= 15 then 'Cold'
    when AVG(w.weather_state*1.0) >= 25 then 'Hot'
    else 'Warm'
end as weather_type
from Countries as c
inner JOIN Weather w 
ON c.country_id = w.country_id 
where w.day between '2019-11-01' and '2019-11-30' 
group by c.country_id;

Q23.
SELECT 
a.product_id, 
round(SUM(a.units * b.price) / SUM(a.units), 2) AS average_price
FROM UnitsSold a
JOIN Prices b
ON (a.product_id = b.product_id
AND a.purchase_date >= b.start_date
AND a.purchase_date <= b.end_date)
GROUP BY product_id;

Q24.
select 
tmp.player_id,
tmp.event_date as first_login
from (select *,
      row_number() over(partition by player_id) as row_num
      from Activity) tmp
where tmp.row_num = 1;

Q25.
select 
tmp.player_id,
tmp.device_id
from (select *,
      row_number() over(partition by player_id) as row_num
      from Activity) tmp
where tmp.row_num = 1;

Q26.
select a.product_name, sum(unit) as unit
from Products a
left join Orders b
on a.product_id = b.product_id
where b.order_date between '2020-02-01' and '2020-02-29'
group by a.product_id
having sum(unit) >= 100;

Q27.
SELECT *
FROM Users
WHERE REGEXP_LIKE(mail, '^[a-zA-Z][a-zA-Z0-9\_\.\-]*@leetcode.com');

select * from Users
where mail regexp '^[a-zA-Z]+[a-zA-Z0-9_\\./\\-]{0,}@leetcode.com$'
order by user_id;

Q28.
select o.customer_id, c.name
from Customers c, Product p, Orders o
where c.customer_id = o.customer_id and p.product_id = o.product_id
group by o.customer_id
having 
(
    sum(case when o.order_date like '2020-06%' then o.quantity*p.price else 0 end) >= 100
    and
    sum(case when o.order_date like '2020-07%' then o.quantity*p.price else 0 end) >= 100
);

Q29.
SELECT DISTINCT title
FROM Content ctt
INNER JOIN TVProgram tv
ON ctt.content_id = tv.content_id
WHERE content_type = 'Movies'
AND Kids_content = 'Y'
AND program_date BETWEEN '2020-06-01' AND '2020-06-30';

Q30. and Q31.
SELECT q.id, q.year, COALESCE(n.npv,0) AS npv
FROM Queries q
LEFT JOIN NPV n
ON q.id = n.id AND q.year=n.year;

Q32.
select en.unique_id,e.name
from employees e left join employeeuni en on e.id=en.id
order by name;

Q33.
select name, sum(ifnull(distance, 0)) as travelled_distance
from Rides r
right join Users u
on r.user_id = u.id
group by name
order by 2 desc,1 asc;

Q34.
select a.product_name, sum(unit) as unit
from Products a
left join Orders b
on a.product_id = b.product_id
where b.order_date between '2020-02-01' and '2020-02-29'
group by a.product_id
having sum(unit) >= 100;

Q35.
SELECT user_name AS results FROM
(
SELECT a.name AS user_name, COUNT(*) AS counts FROM MovieRating AS b
    JOIN Users AS a
    on a.user_id = b.user_id
    GROUP BY b.user_id
    ORDER BY counts DESC, user_name ASC LIMIT 1
) first_query
UNION
SELECT movie_name AS results FROM
(
SELECT c.title AS movie_name, AVG(d.rating) AS rate FROM MovieRating AS d
    JOIN Movies AS c
    on c.movie_id = d.movie_id
    WHERE substr(d.created_at, 1, 7) = '2020-02'
    GROUP BY d.movie_id
    ORDER BY rate DESC, movie_name ASC LIMIT 1
) second_query;

Q36.
select name, sum(ifnull(distance, 0)) as travelled_distance
from Rides r
right join Users u
on r.user_id = u.id
group by name
order by 2 desc,1 asc;

Q37.
select unique_id, name
from Employees
left join EmployeeUNI
on if (Employees.id = EmployeeUNI.id, Employees.id, null);

Q38.
select s.id, s.name
from Students s
left join Departments d
on s.department_id = d.id
where d.id is null;


Q39.
SELECT LEAST(from_id,to_id) as person1,
GREATEST(from_id,to_id) as person2,
COUNT(*) as call_count,
SUM(duration) as total_duration
FROM Calls
GROUP BY person1,person2;

Q40.
select p.product_id, 
    round(sum(p.price * u.units)/sum(u.units), 2) as average_price
from Prices p
left join UnitsSold u
on p.product_id = u.product_id and 
    datediff(u.purchase_date, p.start_date) >= 0 and
    datediff(p.end_date, u.purchase_date) >= 0
group by p.product_id;

Q41.
select name as warehouse_name, sum(units * vol) as volume
from Warehouse w
join (select product_id, Width*Length*Height as vol
     from Products) p
on w.product_id = p.product_id
group by name;

Q42.
select a.sale_date, (a.sold_num - b.sold_num) as diff 
from Sales a left join Sales b
on a.sale_date = b.sale_date
where a.fruit = 'apples' and b.fruit = 'oranges';

Q43.
WITH CTE AS (
SELECT
player_id, min(event_date) as event_start_date
from
Activity
group by player_id )

SELECT
round((count(distinct c.player_id) / (select count(distinct player_id) from Activity)),2)as fraction
FROM
CTE c
JOIN Activity a
on c.player_id = a.player_id
and datediff(c.event_start_date, a.event_date) = -1;


Q44.
select 
    a.name 
from 
    Employee a 
inner join 
    Employee b 
on (a.id = b.managerid) 
group by a.name 
having count(distinct b.id) >= 5;

Q45.
select 
    a.dept_name,
    coalesce(count(student_id), 0) student_number
from 
    Department a 
left join
    Student b
on 
    (a.dept_id = b.dept_id)
group by a.dept_name
order by student_number desc, a.dept_name asc;

Q46.
SELECT
    customer_id
FROM customer
GROUP BY customer_id
HAVING COUNT( DISTINCT product_key) = (SELECT COUNT(*) FROM product);

Q47.
SELECT
    project_id,
    employee_id
FROM (
    SELECT
        p.project_id,
        p.employee_id,
        DENSE_RANK() OVER(PARTITION BY p.project_id ORDER BY e.experience_years DESC) as rnk
    FROM Project as p JOIN Employee as e
    ON p.employee_id = e.employee_id
    ) x
WHERE rnk = 1;

Q48.
select Books.book_id, name from Books join Orders
    on Books.book_id = Orders.book_id
    where available_from < '2019-05-23'
    and dispatch_date between '2018-06-23' and '2019-06-23'
    group by Books.book_id
    having sum(quantity) < 10
    union
select book_id, name from Books
    where available_from < '2019-05-23'
    and book_id not in (
        select distinct book_id from Orders where dispatch_date between '2018-06-23' and '2019-06-23'
    );

Q49.
select e.student_id, e.course_id, e.grade
from (
  select *, row_number() over (partition by student_id order by grade desc) rn
  from Enrollments
) e
where e.rn = 1;

Q50.
select group_id,player_id from 
(select group_id,player_id,sum((
    case when player_id = first_player then first_score
         when player_id = second_player then second_score
         end
)) as totalScores
from Players p,Matches m
where p.player_id = m.first_player
or p.player_id = m.second_player
group by group_id,player_id
order by group_id,totalScores desc,player_id) as temp
group by group_id
order by group_id,totalScores desc,player_id;

------------------------------------------------------------------------------------------------------------------------------------------------------
SET_2:
------------------------------------------------------------------------------------------------------------------------------------------------------
Q51.
SELECT name,population,area
FROM World
WHERE area > 3000000 or population > 25000000;

Q52.
select name from Customer where referee_id != 2

Q53.
SELECT C.Name FROM Customers C LEFT JOIN Orders O ON C.Id = O.CustomerId WHERE O.CustomerId is NULL;

Q54.
SELECT employee_id, COUNT(team_id) OVER (PARTITION BY team_id) team_size
FROM Employee;

Q55.
SELECT
 co.name AS country
FROM
 Person p
 JOIN
     Country co
     ON SUBSTRING(phone_number,1,3) = country_code
 JOIN
     Calls c
     ON p.id IN (c.caller_id, c.callee_id)
GROUP BY
 co.name
HAVING
 AVG(duration) > (SELECT AVG(duration) FROM Calls);

Q56.
select player_id,device_id from activity a
where event_date=(select min(event_date) from activity group by player_id having player_id=a.player_id);

Q57.
SELECT
    customer_number
FROM
    Orders
GROUP BY customer_number
ORDER BY COUNT(*) DESC
LIMIT 1
;

Q58.
SELECT
    DISTINCT t1.seat_id
FROM Cinema AS t1 JOIN Cinema AS t2
ON abs(t1.seat_id - t2.seat_id) = 1
AND t1.free = 1 AND t2.free = 1
ORDER BY 1; 

Q59.
SELECT name
FROM Salesperson
WHERE sales_id
NOT IN (
    SELECT s.sales_id FROM Orders o
    INNER JOIN Salesperson s ON o.sales_id = s.sales_id
    INNER JOIN Company c ON o.com_id = c.com_id
    WHERE c.name = 'RED'
);

Q60.
SELECT
    x,
    y,
    z,
    CASE WHEN x + y > z AND y + z > x AND z + x > y THEN 'Yes'
        ELSE 'No' END AS triangle
FROM Triangle;

Q61.
select min(abs(p2.x-p1.x)) as shortest
from Point p1, Point p2
where p1.x != p2.x;

Q62.
SELECT actor_id, director_id
FROM ActorDirector
GROUP BY actor_id, director_id
HAVING COUNT(*) >= 3;

Q63.
select p.product_name, s.year, s.price
from Product p
join Sales s
on s.product_id = p.product_id;

Q64.
select project_id , round(avg(experience_years), 2) as average_years
from Project as p
left join Employee as e
on p.employee_id = e.employee_id
group by project_id;

Q65.
select a.seller_id
from 
(select seller_id, sum(price) as sum 
from Sales
group by seller_id) a 
where a.sum = (select max(b.sum)from(select seller_id, sum(price) as sum 
from Sales
group by seller_id)b );

Q66.
select distinct buyer_id from Sales s
join Product p
on p.product_id = s.product_id
where p.product_name = 'S8'
and buyer_id not in
(
select buyer_id from Sales s
    join Product p on p.product_id = s.product_id
    where p.product_name = 'iPhone'
);

Q67.
with cte as(
select 
visited_on,
sum(amount) amount
from customer
group by visited_on)

select 
visited_on,
amount,
average_amount 
from(
select visited_on,
sum(amount) over(order by visited_on rows between 6 preceding  and current row) as amount,
round(sum(amount) over(order by visited_on rows between 6 preceding  and current row)/7,2) as average_amount,
lag(visited_on,6) over(order by visited_on) as prev_6
from cte)a
where prev_6 is not null
order by visited_on;

Q68.
select s1.gender, s1.day, sum(s2.score_points) as total from Scores s1, Scores s2
where s1.gender = s2.gender and s1.day >= s2.day
group by s1.gender, s1.day
order by s1.gender, s1.day;

Q69.
select min(log_id) as start_id, max(log_id) as end_id
from (select l.log_id, (l.log_id - l.row_num) as diff
      from (select log_id, row_number() over() as row_num from Logs) l
      ) l2
group by diff;

Q70.
select a.student_id, a.student_name, b.subject_name, count(c.subject_name) as attended_exams
from Students as a
join Subjects as b
left join Examinations as c
on a.student_id = c.student_id and b.subject_name = c.subject_name
group by a.student_id, b.subject_name;

Q71.
select e3.employee_id from Employees e1, Employees e2, Employees e3
where e1.manager_id = 1 and e2.manager_id = e1.employee_id and e3.manager_id = e2.employee_id and e3.employee_id != 1;

Q72.
SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month, country
       , COUNT(1) AS trans_count
       , COUNT(if(state = 'approved', 1, NULL)) AS approved_count
       , SUM(amount) AS trans_total_amount
       , SUM(if(state = 'approved', amount, 0)) AS approved_total_amount
FROM Transactions
GROUP BY month, country;

Q73.
SELECT ROUND(AVG(percentage),2) AS average_daily_percent
FROM (
SELECT action_date, 
(COUNT(DISTINCT b.post_id)/COUNT(DISTINCT a.post_id))*100 AS percentage 
FROM Actions AS a
LEFT JOIN Removals AS b
ON a.post_id = b.post_id
WHERE a.action = 'report'
AND a.extra = 'spam'
GROUP BY a.action_date
) AS tmp;

Q74. and Q75.
WITH CTE AS (
SELECT
player_id, min(event_date) as event_start_date
from
Activity
group by player_id )

SELECT
round((count(distinct c.player_id) / (select count(distinct player_id) from Activity)),2)as fraction
FROM
CTE c
JOIN Activity a
on c.player_id = a.player_id
and datediff(c.event_start_date, a.event_date) = -1;

Q76.
SELECT 
    t1.company_id,
    t1.employee_id,
    t1.employee_name,
    ROUND(CASE WHEN t2.max_sal >= 1000 AND t2.max_sal <= 10000 then salary * 0.76
        WHEN t2.max_sal > 10000 THEN salary * 0.51 
        Else salary end, 0) as salary
FROM Salaries as t1 JOIN (SELECT company_id, MAX(salary) as max_sal FROM Salaries GROUP BY 1) as t2
ON t1.company_id = t2.company_id;

Q77.
select e.left_operand, e.operator, e.right_operand,
    case
        when e.operator = '<' then if(l.value < r.value,'true','false')
        when e.operator = '>' then if(l.value > r.value,'true','false')
        else if(l.value = r.value,'true','false')
    end as value
from Expressions e 
left join Variables l on e.left_operand = l.name 
left join Variables r on e.right_operand = r.name;

Q78.
SELECT
 co.name AS country
FROM
 Person p
 JOIN
     Country co
     ON SUBSTRING(phone_number,1,3) = country_code
 JOIN
     Calls c
     ON p.id IN (c.caller_id, c.callee_id)
GROUP BY
 co.name
HAVING
 AVG(duration) > (SELECT AVG(duration) FROM Calls);
 
Q79.
SELECT name FROM Employee ORDER BY name;

Q80.
with cte as(
select extract(year from transaction_date) as year,product_id,spend as curr_year_spend,
round(lag(spend) over(PARTITION BY product_id order by extract(year from transaction_date)),2)
as prev_year_spend
from user_transaction)
select * ,
case when prev_year_spend is not null then round(((curr_year_spend-prev_year_spend)/prev_year_spend*100),2)
else prev_year_spend end as yoy_rate
from cte ;

Q81.
SELECT item_type,
    (CASE WHEN item_type = 'prime_eligible' 
          THEN floor(500000/total_square_footage) * total_item_type
          ELSE floor(((500000) - (floor(500000/(SELECT SUM(square_footage) FROM inventory WHERE item_type = 'prime_eligible'))* 
          (SELECT SUM(square_footage) FROM inventory WHERE item_type = 'prime_eligible')))/(total_square_footage)
          ) * total_item_type END) AS item_count   

FROM(SELECT item_type,
      COUNT(item_type) AS total_item_type,
      SUM(square_footage) AS total_square_footage
FROM inventory
GROUP BY item_type) AS temp_table1       
ORDER BY item_count DESC;

Q82.
WITH CTE AS
(
SELECT 
user_id,
event_date,
EXTRACT(MONTH FROM event_date) - LAG(EXTRact(MONTH FROM event_date)) OVER(partition by user_id order by event_date) as month_number 
FROM 
user_actions
) 
SELECT
Extract(month FROM event_date) as month,
COUNT(*) as monthly_active_users FROM
CTE
WHERE month_number = 1
GROUP by 1
ORDER BY 2 desc
LIMIT 1;

Q83.
with cte as(
select searches
from search_frequency
group by searches,generate_series(1,num_users)
)
select round(percentile_cont(0.5) within group(order by searches)::decimal,1) as median
from search_frequency;

Q84.
WITH payment_status AS (
SELECT
  advertiser.user_id,
  advertiser.status,
  payment.paid
FROM advertiser
LEFT JOIN daily_pay AS payment
  ON advertiser.user_id = payment.user_id

UNION

SELECT
  payment.user_id,
  advertiser.status,
  payment.paid
FROM daily_pay AS payment
LEFT JOIN advertiser
  ON advertiser.user_id = payment.user_id
)

SELECT
  user_id,
  CASE WHEN paid IS NULL THEN 'CHURN'
  	WHEN status != 'CHURN' AND paid IS NOT NULL THEN 'EXISTING'
  	WHEN status = 'CHURN' AND paid IS NOT NULL THEN 'RESURRECT'
  	WHEN status IS NULL THEN 'NEW'
  END AS new_status
FROM payment_status
ORDER BY user_id;

Q85.
with cte as(
select server_id,status_time,
case when session_status='stop' then  lag(status_time) over(partition by server_id order by status_time) 
 end as prev_time
 from server_utilization1
 )
 select round(sum(running_time)/86400) as total_uptime_days from(
 select server_id,sum(timestampdiff(second,prev_time,status_time)) running_time
 from cte
 where prev_time is not null
 group by server_id)a;
 
Q86.
select count(t1.transaction_id) as payment_count
from transactions t1 inner join transactions t2 
on t1.merchant_id=t2.merchant_id and t1.credit_card_id=t2.credit_card_id and t1.amount=t2.amount
and t2.transaction_timestamp>t1.transaction_timestamp
where timestampdiff(minute,t1.transaction_timestamp,t2.transaction_timestamp)<10;

Q87.
with cte as(
select o.customer_id,o.status,c.signup_timestamp,o.order_timestamp
from orders o inner join  trips t on o.trip_id=t.trip_id 
inner join customer c on c.customer_id=o.customer_id
where extract(year from c.signup_timestamp)=2022 and month(c.signup_timestamp)=6 and datediff(o.order_timestamp,c.signup_timestamp)<=14
)
select round((100.0*count(case when status in('completed incorrectly','never received') then 1 else null end)/count(customer_id)),2)
as bad_experience_pct
from cte;

Q88.
select gender,day,sum(score_points) over(partition by gender order by day) as total 
from scores
order by gender;

Q89.
with cte1 as(
select id ,name,phone_number,
case when substring(phone_number,1,1)=0 then substring(phone_number,2,2) 
	 else substring(phone_number,1,3) end as country_code
     from person),
cte2 as(
select cn.name,c.duration
from calls c inner join cte1 ct on c.caller_id=ct.id or c.callee_id=ct.id  left join country cn on ct.country_code=cn.country_code
order by caller_id)
select name from cte2
group by name 
having avg(duration)>(select avg(duration) from cte2);

Q90.
WITH searches_expanded AS (
  SELECT num
  FROM numbers
  GROUP BY 
    num, 
    GENERATE_SERIES(1, frequency))

SELECT 
  ROUND(PERCENTILE_CONT(0.50) WITHIN GROUP (
    ORDER BY num)::DECIMAL, 1) AS  median
FROM searches_expanded;

or

SET @rowindex := -1;
 
SELECT
   AVG(d.frequency) as Median 
FROM
   (SELECT @rowindex:=@rowindex + 1 AS rowindex,
           Numbers.frequency AS frequency
    FROM Numbers
    ORDER BY Numbers.frequency) AS d
WHERE
d.rowindex IN (FLOOR(@rowindex / 2), CEIL(@rowindex / 2));

Q91.
with cte1 as(
select s.pay_date,round(avg(amount),2) as comp_avg_month
from salary s inner join employee e
on s.employee_id=e.employee_id
group by month(pay_date)
),
cte2 as (
select e.department_id,s.pay_date,round(avg(amount),2) as avg_month
from salary s inner join employee e
on s.employee_id=e.employee_id
group by e.department_id,s.pay_date
)
       
select date_format(c2.pay_date,'%Y-%m') as pay_month,c2.department_id,
case when c2.avg_month>c1.comp_avg_month then 'higher'
	 when c2.avg_month<c1.comp_avg_month then 'lower'
     else 'same' end as comparison
from
cte1 c1 left join cte2 c2 
on c1.pay_date=c2.pay_date
order by department_id,month(c2.pay_date);

Q92.
with cte as(
select player_id,event_date as curr_date,lead(event_date) over(partition by player_id order by event_date) as next_date
from activity
),
cte1 as(
select distinct(player_id),curr_date,
case when datediff(next_date,curr_date)= 1 then 1 else 0 end as chk
from cte
group by player_id)

select curr_date as install_dt,count(player_id) as installs,round((sum(chk)/count(chk)),1)as retention_rate
from cte1
group by curr_Date;

Q93.
with cte as(
select m.first_player as player,m.first_score as score,p.group_id
from matches m inner join players p on m.first_player=p.player_id
union all
select m.second_player as player,m.second_score as score,p.group_id
from matches m inner join players p on m.second_player=p.player_id
),
cte2 as(
select group_id,player,sum(score)as total_score
from cte group by group_id,player
)select group_id,player as player_id from(
select group_id,player,rank() over(partition by group_Id order by total_score desc ,player)as rn
from cte2)a
where rn=1;

Q94. and Q95.
with cte1 as(
select exam_id,max(score) as max_score,min(score) as min_score
from exam group by exam_id
),cte2 as(
select distinct e.student_id,s.student_name,e.exam_id,e.score,c.min_score ,c.max_score
from exam e left join student s
on e.student_id=s.student_id left join cte1 c on c.exam_id=e.exam_id
)
select student_id,student_name
from cte2 c where score <>min_score and score<>max_score
group by student_id having count(student_id)=(select count(student_id) from exam where c.student_id=student_id group by student_id)

Q96.
select user_id,song_id,sum(song_plays) as song_plays from(
select user_id,song_id,song_plays from 
song_history union all
select user_id,song_id,count(song_id) as song_plays
from songs_weekly
where listen_time<='2022-08-04 23:59:59'
GROUP BY user_id,song_id)report
group by user_id,song_id
order by song_plays desc;

Q97.
with cte as(
select e.email_id,t.text_id,e.signup_date,t.signup_action
from emails e left join texts t
on e.email_id=t.email_id
group by email_id having text_id=max(text_id) or text_id is null)
select 
	round((count(case when signup_action='Confirmed' then 1 else null end)/count(email_id)),2) as confirm_rate
    from cte;

Q98.
with cte as(
select user_id,tweet_date,count(user_id) as tweet_count
from tweets
group by user_id,date(tweet_date)
)
select user_id,tweet_date,
round(sum(tweet_count) over(partition by user_id order by tweet_date rows between 2 preceding and current row) /
count(user_id) over(partition by user_id order by tweet_date rows between 2 preceding and current row),2) as rolling_avg_3_days
from cte 
order by user_id;

Q99.
select * from(
select ab.age_bucket,
round(100.0*sum(case when activity_type='send' then time_spent else 0 end)/sum(time_spent),2) as 'send_perc',
round(100.0*sum(case when activity_type='open' then time_spent else 0 end)/sum(time_spent),2) as 'open_perc'
from activities a left join age_breakdown ab
on a.user_id=ab.user_id
group by age_bucket
order by age_bucket)a
where send_perc <> 0 and open_perc <>0;

Q100.
with cte as(
select ec.personal_profile_id,ec.company_id,cp.name,cp.followers as company_followers
from employee_company ec left join company_pages cp
on ec.company_id=cp.company_id)
select profile_id from personal_profiles p
where followers>(select max(company_followers) from cte where personal_profile_id=p.profile_id group by personal_profile_id)
order by profile_id;

------------------------------------------------------------------------------------------------------------------------------------------------------
SET_3:
------------------------------------------------------------------------------------------------------------------------------------------------------

Q101. and Q102.
with cte as(
select *,rank() over(partition by username order by enddate desc) as rn,
lead(enddate) over(partition by username order by enddate desc) as next_activity
from useractivity
)
select username,activity,startdate,enddate
from cte
where (rn=2 and next_activity is not null) or (rn=1 and next_activity is null);

Q103.
select name from student
where marks>75 
order by substring(name,-3,3) ,id;

Q104.
select name from employee
where salary > 2000 and months <10
order by employee_id;

Q105.
SELECT
    CASE
        WHEN A = B AND A = C AND B = C 
            THEN 'Equilateral'
        WHEN (A = B OR A = C OR B = C) AND (A+B>C ) AND(B+C>A) AND(C+A)>B
            THEN 'Isosceles'
        WHEN A != B AND B != C AND (A+B>C ) AND(B+C>A) AND(C+A)>B
            THEN 'Scalene'
        ELSE 'Not A Triangle'
    END as types_of_triangle
FROM TRIANGLES;

Q106.
select  
ceil(avg(salary)-avg(replace(salary,'0',''))) as avg_salary 
from employees;

Q107.
select salary*months as earning,count(*) as no_of_employee
from employee where salary*months=(select max(salary*months) from employee);

Q108.
-- 1st Query output
select concat(name,'(',substr(occupation,1,1),')') as name
from occupations;

-- 2nd Query Output
with cte as(
select occupation,count(*) as occ_count
from occupations group by occupation)

select concat('There are a total of ',occ_count,' ',occupation,'s') as statement
from cte
order by occ_count;

Q109.
select Doctor,Professor,Singer,Actor from(
select
    rn,
    max(case when occupation = 'Doctor' then name end) Doctor,
    max(case when occupation = 'Professor'  then name end) Professor,
    max(case when occupation = 'Singer' then name end) Singer,
    max(case when occupation = 'Actor'  then name end) Actor
from (
    select o.*, row_number() over(partition by occupation order by name) rn
    from occupations o
)a
group by rn)b;

Q110.
select n,
case 
  when p is null then 'root'
  when n not in(select distinct p from bst where p is not null) then 'leaf'
  else 'inner' 
end as type
from bst
order by n;
		
Q111.
SELECT C.COMPANY_CODE,
       C.FOUNDER,
  (SELECT COUNT(DISTINCT LEAD_MANAGER_CODE) 
   FROM LEAD_MANAGER L
   WHERE L.COMPANY_CODE = C.COMPANY_CODE) as lead_manager_count,
  (SELECT COUNT(DISTINCT SENIOR_MANAGER_CODE)
   FROM SENIOR_MANAGER S
   WHERE S.COMPANY_CODE = C.COMPANY_CODE) as senior_manager_count,
  (SELECT COUNT(DISTINCT MANAGER_CODE)
   FROM MANAGER M
   WHERE M.COMPANY_CODE = C.COMPANY_CODE) as manager_count,
  (SELECT COUNT(DISTINCT EMPLOYEE_CODE) 
   FROM EMPLOYEE E
   WHERE E.COMPANY_CODE = C.COMPANY_CODE)as employee_count
FROM COMPANY C
ORDER BY C.COMPANY_CODE ASC;

Q112.
SET @range = 1000;

SELECT GROUP_CONCAT(R2.n SEPARATOR '&') as prime_number
FROM (
        SELECT @ctr2:=@ctr2+1 "n"
        FROM information_schema.tables R2IS1,
        information_schema.tables R2IS2,
        (SELECT @ctr2:=1) TI
        WHERE @ctr2<@range
     ) R2
WHERE NOT EXISTS 
(
SELECT R1.n
FROM (
        SELECT @ctr1:=@ctr1+1 "n"
        FROM information_schema.tables R1IS1,
        information_schema.tables R1IS2,
        (SELECT @ctr1:=1) I1
        WHERE @ctr1<@range
     ) R1
WHERE R2.n%R1.n=0 AND R2.n>R1.n
);

Q113.
set @row := 0;
select repeat('* ', @row := @row + 1)as pattern from information_schema.tables where @row < 5;

Q114.
with recursive num(n) as
(
select 10
    union all
    select n - 2
    from num 
    where n - 2 >= 2
)
select lpad('', num.n, '* ') as pattern
from num; 

Q115.
select name from student
where marks>75 
order by substring(name,-3,3) ,id;

Q116.
a.
select distinct x1,y1 from(
select f1.x as x1,f1.y as y1,f2.x as x2,f2.y as y2
from functions f1 inner join functions f2
on f1.x=f2.y and f1.y=f2.x)a
where x1<=y1
order by x1;

b.
select name from employee order by name;

Q117.
select name from employee
where salary > 2000 and months <10
order by employee_id;

Q118.
SELECT
    CASE
        WHEN A = B AND A = C AND B = C 
            THEN 'Equilateral'
        WHEN (A = B OR A = C OR B = C) AND (A+B>C ) AND(B+C>A) AND(C+A)>B
            THEN 'Isosceles'
        WHEN A != B AND B != C AND (A+B>C ) AND(B+C>A) AND(C+A)>B
            THEN 'Scalene'
        ELSE 'Not A Triangle'
    END as types_of_triangle
FROM TRIANGLES;

Q119.
with cte as(
select extract(year from transaction_date) as year,product_id,spend as curr_year_spend,
round(lag(spend) over(PARTITION BY product_id order by extract(year from transaction_date)),2)
as prev_year_spend
from user_transaction)

select * ,
case when prev_year_spend is not null then round(((curr_year_spend-prev_year_spend)/prev_year_spend*100),2)
else prev_year_spend end as yoy_rate
from cte ;

Q120.
SELECT item_type,
    (CASE WHEN item_type = 'prime_eligible' 
          THEN floor(500000/total_square_footage) * total_item_type
          ELSE floor(((500000) - (floor(500000/(SELECT SUM(square_footage) FROM inventory WHERE item_type = 'prime_eligible'))* 
          (SELECT SUM(square_footage) FROM inventory WHERE item_type = 'prime_eligible')))/(total_square_footage)
          ) * total_item_type END) AS item_count   

FROM(SELECT item_type,
      COUNT(item_type) AS total_item_type,
      SUM(square_footage) AS total_square_footage
FROM inventory
GROUP BY item_type) AS temp_table1       
ORDER BY item_count DESC;

Q121.
WITH CTE AS
(
SELECT 
user_id,
event_date,
EXTRACT(MONTH FROM event_date) - LAG(EXTRact(MONTH FROM event_date)) OVER(partition by user_id order by event_date) as month_number 
FROM 
user_actions
) 
SELECT
Extract(month FROM event_date) as month,
COUNT(*) as monthly_active_users FROM
CTE
WHERE month_number = 1
GROUP by 1
ORDER BY 2 desc
LIMIT 1;

Q122.
with cte as(
select searches
from search_frequency
group by searches,generate_series(1,num_users)
)
select round(percentile_cont(0.5) within group(order by searches)::decimal,1) as median
from search_frequency;

Q123.
WITH payment_status AS (
SELECT
  advertiser.user_id,
  advertiser.status,
  payment.paid
FROM advertiser
LEFT JOIN daily_pay AS payment
  ON advertiser.user_id = payment.user_id
  
UNION

SELECT
  payment.user_id,
  advertiser.status,
  payment.paid
FROM daily_pay AS payment
LEFT JOIN advertiser
  ON advertiser.user_id = payment.user_id
)

SELECT
  user_id,
  CASE WHEN paid IS NULL THEN 'CHURN'
  	WHEN status != 'CHURN' AND paid IS NOT NULL THEN 'EXISTING'
  	WHEN status = 'CHURN' AND paid IS NOT NULL THEN 'RESURRECT'
  	WHEN status IS NULL THEN 'NEW'
  END AS new_status
FROM payment_status
ORDER BY user_id;

Q124.
with cte as(
select server_id,status_time,
case 
 when session_status='stop' then  lag(status_time) over(partition by server_id order by status_time) 
end as prev_time
from server_utilization)
 
select round(sum(running_time)/86400) as total_uptime_days from(
select server_id,sum(timestampdiff(second,prev_time,status_time)) running_time
from cte
where prev_time is not null
group by server_id)a;
 
Q125.
select count(t1.transaction_id) as payment_count
from transactions t1 
inner join transactions t2 
on t1.merchant_id=t2.merchant_id 
and t1.credit_card_id=t2.credit_card_id 
and t1.amount=t2.amount
and t2.transaction_timestamp>t1.transaction_timestamp
where timestampdiff(minute,t1.transaction_timestamp,t2.transaction_timestamp)<10;

Q126.
with cte as(
select o.customer_id,o.status,c.signup_timestamp,o.order_timestamp
from orders o 
inner join  trips t 
on o.trip_id=t.trip_id 
inner join customer c 
on c.customer_id=o.customer_id
where extract(year from c.signup_timestamp)=2022 
and month(c.signup_timestamp)=6 
and datediff(o.order_timestamp,c.signup_timestamp)<=14
)

select round((100.0*count(case when status in('completed incorrectly','never received') then 1 else null end)/count(customer_id)),2)
as bad_experience_pct
from cte;

Q127.
select gender,day,sum(score_points) over(partition by gender order by day) as total 
from scores
order by gender;

Q128.
with cte1 as(
select id ,name,phone_number,
case when substring(phone_number,1,1)=0 then substring(phone_number,2,2) 
	 else substring(phone_number,1,3) end as country_code
     from person),
	 
cte2 as(
select cn.name,c.duration
from calls c inner join cte1 ct on c.caller_id=ct.id or c.callee_id=ct.id  left join country cn on ct.country_code=cn.country_code
order by caller_id)

select name from cte2
group by name 
having avg(duration)>(select avg(duration) from cte2);

Q129.
WITH searches_expanded AS (
  SELECT num
  FROM numbers
  GROUP BY 
    num, 
    GENERATE_SERIES(1, frequency))

SELECT 
  ROUND(PERCENTILE_CONT(0.50) WITHIN GROUP (
    ORDER BY num)::DECIMAL, 1) AS  median
FROM searches_expanded;

Q130.
with cte1 as(
select s.pay_date,round(avg(amount),2) as comp_avg_month
from salary s inner join employee e
on s.employee_id=e.employee_id
group by month(pay_date)),
cte2 as (
select e.department_id,s.pay_date,round(avg(amount),2) as avg_month
from salary s inner join employee e
on s.employee_id=e.employee_id
group by e.department_id,s.pay_date)

select date_format(c2.pay_date,'%Y-%m') as pay_month,c2.department_id,
case when c2.avg_month>c1.comp_avg_month then 'higher'
	 when c2.avg_month<c1.comp_avg_month then 'lower'
     else 'same' 
end as comparison
from
cte1 c1 left join cte2 c2 
on c1.pay_date=c2.pay_date
order by department_id,month(c2.pay_date);

Q131.

Q132.
Q133.
Q134.
Q135.
Q136.
Q137.
Q138.
Q139.

Q140.
Q141.
Q142.
Q143.
Q144.
Q145.
Q146.
Q147.
Q148.
Q149.

Q150.

Q151.
select * from transactions;
with cte as(
select *,
transaction_date -row_number() over(partition by user_id order by transaction_date) as gp_date
from transactions)

select distinct user_id
from cte
group by user_id,date(gp_date) having count(*)>=3;
	
Q152.
with cte as(
select rental_id,group_concat(amentity order by amentity) as amentities
from rental_amenities
group by rental_id)
select count(*) as matching_airbnb from(
select amentities,count(distinct amentities) as gp_match
from cte
group by amentities having count(*)>1)a;

Q153.
select advertiser_id, round(sum(revenue)/sum(spend),2) as ROAS
from ad_campaigns
group by advertiser_id
order by advertiser_id;

Q154.
with cte as(
select title,round(avg(salary),2) as avg_salary
from employee_pay
group by title
)

select employee_Id ,salary ,status 
from(
select 
e.employee_id,e.salary,
case when e.salary > 2*c.avg_salary then 'Overpaid'
	when e.salary < c.avg_salary/2 then 'Underpaid'
end as status
from  employee_pay e inner join cte c 
on e.title=c.title)a
where status is not null;
			
Q155.
select count(p1.payer_id) as unique_relationships
from payments p1 
inner join payments p2
on p1.payer_id=p2.recipient_id 
and p1.recipient_id=p2.payer_id 
and p1.payer_id>p2.payer_id;

Q156.
select count(distinct user_id) as repeated_customers
from purchases 
group by user_id,product_id 
having count(distinct purchase_time)>=2;

Q157.
with cte as(
select transaction_id,type,transaction_date,
case when type='withdrawal' then  -1*amount
else amount end as amount 
from transactions)

select transaction_date,round(sum(amount),2) as balance
from cte
group by day(transaction_date)
order by date(transaction_date);
 
Q158.
with cte as(
select category,product,round(sum(spend),2) as total_spend
from product_spend
where year(transaction_date)=2022
group by category,product)

select category,product,total_spend from(
select category,product,total_spend,dense_rank() over(partition by category order by total_spend desc) as rn
from cte)a
where rn in(1,2)
order by category,product,total_spend;

Q159.
with cte as(
select user_id,signup_date,last_login,
WEEK(signup_date,6) - WEEK(DATE_SUB(signup_date, INTERVAL DAYOFMONTH(signup_date)-1 DAY),6)+1 as signup_week,
case
 when datediff(last_login,signup_date)<28 then 1
 else 0 
end as chk
from users)
	   
select signup_week,round((100.0*sum(chk)/count(chk)),2) as churn_rate
from cte
group by signup_week;

-----------------------------------------------------------------------------------------------------------------------------------
END
-----------------------------------------------------------------------------------------------------------------------------------
